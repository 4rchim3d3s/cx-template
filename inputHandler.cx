/***************************************
 * Author:
 * Date:
 * Version:
***************************************/
package inputHandler
/***************************************
 * Import CX modules.
***************************************/

import "glfw"

/***************************************
 * Import custom modules.
***************************************/
import "main"
import "screenHandler"

/***************************************
 * Setting Variables
***************************************/

//--> variables for the mouse cursor 
var mouse_x f64
var mouse_y f64

var mouse_right_click bool
var mouse_right_hold bool
var mouse_right_release bool

var mouse_left_click bool
var mouse_left_hold bool
var mouse_left_release bool

var TESTSLIDER_FREE bool

/***************************************
 * Declaration struct
***************************************/

/***************************************
 * Functions
***************************************/

/* Function     : init
   Input        : Identifier for the window (window str)
                : Identifier for the screen (screen str)
   Description  : Sets the Callbacks for the mouse and keyboard depending on the input
				: Note: you have to name the callback funcs depending on the screen they are used for
				: 		e.g.: 'func SCREEN_MAIN' is the keyboard-callback for SCREEN_MAIN
				:			  'func SCREEN_MAIN_mouseButtons' is the mouse-callback for SCREEN_MAIN
*/
func init(window str, screen str){
	glfw.SetMouseButtonCallback(window, str.concat(screen, "_mouseButtons"))
	glfw.SetKeyCallback(window, screen)
}

/* Function     : SCREEN_MAIN
   Input        : Identifier for the window (window str)
				: The used key (key i32)
				: Platform-specific scancode (scancode i32)
				: The action of the key (action  i32)
				: Modifier bit (mods i32)
   Description  : Keyboard-Callback for SCREEN_MAIN - Makes actions depending on the key that was pressed inside window
*/
func SCREEN_MAIN(window str, key i32, scancode i32, action i32, mods i32) {

	if bool.and(i32.eq(key, 262), i32.eq(action, 1)) {
		str.print("RIGHT")
	}
	if bool.and(i32.eq(key, 263), i32.eq(action, 1)) {
		str.print("LEFT")
	}
	if bool.and(i32.eq(key, 264), i32.eq(action, 1)) {
		str.print("DOWN")
	}
	if bool.and(i32.eq(key, 265), i32.eq(action, 1)) {
		str.print("UP")
	}
	if bool.and(i32.eq(key, 256), i32.eq(action, 1)) {
		str.print("ESCAPE")
		main.EXIT_FLAG = true	//Set EXIT_FLAG to close main.WINDOW_NAME
	}
	if bool.and(i32.eq(key, 257), i32.eq(action, 1)) {
		str.print("ENTER")
	}
}

/* Function     : SCREEN_MAIN_mouseButtons
   Input        : Identifier for the window (window str)
				: The used key (key i32)
				: Platform-specific scancode (scancode i32)
				: The action of the key (action  i32)
				: Modifier bit (mods i32)
   Description  : MouseButton-Callback for SCREEN_MAIN - Makes actions depending on the button over whom the left Mouse-Button was released
*/
func SCREEN_MAIN_mouseButtons(window str, key i32, action i32, mods i32) () {

	updateMouseButtons(key, action)
	
	if leftMouseButtonReleased("PLAY", key, action) {
		screenHandler.setScreen(screenHandler.SCREEN_GAME)
	}
	if leftMouseButtonReleased("SETTINGS", key, action){
		screenHandler.setScreen(screenHandler.SCREEN_SETTINGS)
	}
	if leftMouseButtonReleased("EXIT", key, action){
		str.print("MOUSE -> EXIT")
		main.EXIT_FLAG = true	//Set EXIT_FLAG to close main.WINDOW_NAME
	}
}

/* Function     : SCREEN_GAME
   Input        : Identifier for the window (window str)
				: The used key (key i32)
				: Platform-specific scancode (scancode i32)
				: The action of the key (action  i32)
				: Modifier bit (mods i32)
   Description  : Keyboard-Callback for SCREEN_GAME - Makes actions depending on the key that was pressed inside window
*/
func SCREEN_GAME(window str, key i32, scancode i32, action i32, mods i32) {

	if bool.and(i32.eq(key, 262), i32.eq(action, 1)) {
		str.print("RIGHT")
	}
	if bool.and(i32.eq(key, 263), i32.eq(action, 1)) {
		str.print("LEFT")
	}
	if bool.and(i32.eq(key, 264), i32.eq(action, 1)) {
		str.print("DOWN")
	}
	if bool.and(i32.eq(key, 265), i32.eq(action, 1)) {
		str.print("UP")
	}
	if bool.and(i32.eq(key, 256), i32.eq(action, 1)) {
		str.print("ESCAPE")
		screenHandler.setScreen(screenHandler.SCREEN_MAIN)
	}
	if bool.and(i32.eq(key, 257), i32.eq(action, 1)) {
		str.print("ENTER")
	}
}

/* Function     : SCREEN_GAME_mouseButtons
   Input        : Identifier for the window (window str)
				: The used key (key i32)
				: Platform-specific scancode (scancode i32)
				: The action of the key (action  i32)
				: Modifier bit (mods i32)
   Description  : MouseButton-Callback for SCREEN_GAME - Makes actions depending on the button over whom the left Mouse-Button was released
*/
func SCREEN_GAME_mouseButtons(window str, key i32, action i32, mods i32) () {

	updateMouseButtons(key, action)

	if leftMouseButtonReleased("BACK", key, action) {
		screenHandler.setScreen(screenHandler.SCREEN_MAIN)
	}
}

/* Function     : SCREEN_SETTINGS
   Input        : Identifier for the window (window str)
				: The used key (key i32)
				: Platform-specific scancode (scancode i32)
				: The action of the key (action  i32)
				: Modifier bit (mods i32)
   Description  : Keyboard-Callback for SCREEN_SETTINGS - Makes actions depending on the key that was pressed inside window
*/
func SCREEN_SETTINGS(window str, key i32, scancode i32, action i32, mods i32) {

	if bool.and(i32.eq(key, 262), i32.eq(action, 1)) {
		str.print("RIGHT")
	}
	if bool.and(i32.eq(key, 263), i32.eq(action, 1)) {
		str.print("LEFT")
	}
	if bool.and(i32.eq(key, 264), i32.eq(action, 1)) {
		str.print("DOWN")
	}
	if bool.and(i32.eq(key, 265), i32.eq(action, 1)) {
		str.print("UP")
	}
	if bool.and(i32.eq(key, 256), i32.eq(action, 1)) {
		str.print("ESCAPE")
		screenHandler.setScreen(screenHandler.SCREEN_MAIN)
	}
	if bool.and(i32.eq(key, 257), i32.eq(action, 1)) {
		str.print("ENTER")
	}
}

/* Function     : SCREEN_SETTINGS_mouseButtons
   Input        : Identifier for the window (window str)
				: The used key (key i32)
				: Platform-specific scancode (scancode i32)
				: The action of the key (action  i32)
				: Modifier bit (mods i32)
   Description  : MouseButton-Callback for SCREEN_SETTINGS - Makes actions depending on the button over whom the left Mouse-Button was released
*/
func SCREEN_SETTINGS_mouseButtons(window str, key i32, action i32, mods i32) () {
	
	updateMouseButtons(key, action)
	
	if leftMouseButtonReleased("BACK", key, action) {
		screenHandler.setScreen(screenHandler.SCREEN_MAIN)
	}

	if leftMouseButtonReleased("TESTSWITCH", key, action){ // TODO -> iterate through all switches of screen and then call function -> less code lines
		screenHandler.toggleSwitch("TESTSWITCH")
	}
	if leftMouseButtonReleased("TESTSWITCH2", key, action){ // TODO -> iterate through all switches of screen and then call function -> less code lines
		screenHandler.toggleSwitch("TESTSWITCH2")
	}

}

func actions_with_durations(screen screenHandler.Screen){
	if str.eq(screen.name, screenHandler.SCREEN_SETTINGS){
		for i:=0; i<screen.sliders_count; i++ {	
			if bool.and(mouseAction(screen.sliders[i].id, mouse_left_hold), screen.sliders[i].clicked){
				screenHandler.updateSliderPosition(screen.sliders[i], mouse_x)
			}
		}
	}
}

/* Function     : updateMousePosition
   Desctription : updates the global variables of the mouse cursor
*/
func updateMousePosition(){
	mouse_x, mouse_y = glfw.GetCursorPos(main.WINDOW_MAIN)
}

/* Function     : leftMouseButtonReleased
   Input        : Identifier for the type of object (object_id str)
                : The used key (key i32)
                : The action of the key (action  i32)
   Output       : bool if the left mousebutton was released above the object (released bool)
   Description  : checks if the active object_id is the same where the left mouse button was released
*/
func leftMouseButtonReleased(object_id str, key i32,action i32)(released bool){
	released = false
	if bool.and(bool.and(i32.eq(key, 0), i32.eq(action, 0)), str.eq(object_id,screenHandler.getActiveButton(screenHandler.current_screen))) {
		released = true
	}
	if bool.and(bool.and(i32.eq(key, 0), i32.eq(action, 0)), str.eq(object_id,screenHandler.getActiveSwitch(screenHandler.current_screen))) {
		released = true
	}
	if bool.and(bool.and(i32.eq(key, 0), i32.eq(action, 0)), str.eq(object_id,screenHandler.getActiveSlider(screenHandler.current_screen))) {
		released = true
	}
}

func mouseAction(object_id str, mouseaction bool)(action bool){
	action = false
	if bool.eq(mouseaction,true){
		if str.eq(object_id, screenHandler.getActiveButton(screenHandler.current_screen)) {
			action = true
		}
		if str.eq(object_id, screenHandler.getActiveSwitch(screenHandler.current_screen)) {
			action = true
		}
		if str.eq(object_id,screenHandler.getActiveSlider(screenHandler.current_screen)) {
			action = true
		}
	}
}
/* Function     : leftMouseButtonStaysPressed
   Input        : Identifier for the type of object (object_id str)
                : The used key (key i32)
                : The action of the key (action  i32)
   Output       : bool if the left mousebutton is pressed above the object (pressed bool)
   Description  : checks if the active object_id is the same where the left mouse button is pressed
*/
func leftMouseButtonStaysPressed(object_id str, key i32,action i32)(pressed bool){
	pressed = false
	if bool.and(bool.and(i32.eq(key, 0), i32.eq(action, 1)), str.eq(object_id,screenHandler.getActiveButton(screenHandler.current_screen))) {
		pressed = true	
	}
	if bool.and(bool.and(i32.eq(key, 0), i32.eq(action, 1)), str.eq(object_id,screenHandler.getActiveSwitch(screenHandler.current_screen))) {
		pressed = true
	}
	if bool.and(bool.and(i32.eq(key, 0), i32.eq(action, 1)), str.eq(object_id,screenHandler.getActiveSlider(screenHandler.current_screen))) {
		pressed = true
	}
}


func updateMouseButtons(key i32, action i32)(){
	//left
	if bool.and(i32.eq(key, 0), i32.eq(action, 1)){
		mouse_left_click = true
		mouse_left_hold = true
	}
	if bool.and(i32.eq(key, 0), i32.eq(action, 0)){
		mouse_left_release = true
		mouse_left_hold = false
	}

	//right
	if bool.and(i32.eq(key, 1), i32.eq(action, 1)){
		mouse_right_click = true
		mouse_right_hold = true
	}
	if bool.and(i32.eq(key, 1), i32.eq(action, 0)){
		mouse_right_release = true
		mouse_right_hold = false
	}
}
/***************************************
 * Main
***************************************/

/* Function     : main
   Description  : calls updateMousePosition() to update the cursor position
*/
func main(){
	updateMousePosition()
	actions_with_durations(screenHandler.current_screen)
}

func resetStates(){
	//left
	mouse_left_click = false
	mouse_left_release = false
	//right
	mouse_right_click = false
	mouse_right_release = false
}